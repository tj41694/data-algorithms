# data-algorithms

#### 关于： ####

> 这个工程是我个人学习算法的一个网络备份。代码基本都是根据算法思想自己实现的。

---
*  （BST）  **二叉搜索树**
*  （BST_T）**类包装带模板的二叉搜索树**
*  （BinTreeAVL）**MINI 二叉平衡树**
*  （Sort_Bubble）**冒泡排序**
*  （Sort_Insertion） **直接插入排序**
*  （Sort_Selection）**简单选择排序**
*  （Sort_Quick）**快速排序**

---
###AVL树###

AVL在插入和删除节点的自平衡过程中，平衡因子的计算怎样才能高效？计算左子树与右子树的高度差的过程需要回溯，回溯一定需要在Node中增加一个Node* parent 指针吗？可不可以不增加，也实现回溯并计算每个节点的BF值？明天继续....

今天琢磨了一下，还是在Node中增加一个Node* parent更方便，另外AVL的插入和删除不需要回溯至根节点。

* 插入：1，子树高度不变，对所有父节点bf值无影响。
2，子树高度增加，回溯父节点，计算BF值，如果BF计算后为0则子树高度不变，无需继续回溯，（基本上只需回溯几次就能达到平衡）。
* 删除：1，删除后子树高度不变，无需旋转、回溯。2，删除后子树高度-1，向上回溯，直到父节点为bf调整后未0，或到根节点，（基本上只需回溯几次就能达到平衡）。

使用**指针的指针**以代替**指针的副本**实现旋转操作。

创建一个栈

	struct nodetToChange
	{
		Node** ppTemp;
		int bf;
	};

	std::stack<nodetToChange> nodeStack;

记录每一个节点的fb值的改变量。该值很重要，使回溯计算每一个节点的bf值时可以不使用时间复杂度较高的求树高度的函数,提高性能。

今天再次放弃父指针(但暂时保留在节点结构体中，以方便以后实现其他算法)，使用指向节点的指针的指针在寻路的时候压入栈。比如root指针的指针 我们使用Node** ppTenp = &root。后把此ppTemp传入Rotation函数，以实现对任意节点的旋转操作。

另外，bf值得计算，我为了提升效率，没没有使用笨拙的对每一个节点求左右子树高度再相减的函数。而是在寻路的时候便压入bf值的可能变化值，在回溯的过程中简单与原bf值相加即可。

当然效率是要付出代价的，在旋转后，有两个节点需要重新计算bf值，这里我花了很多时间，根据二叉树的特性，分情况分析了fb值在旋转后所有可能的变化，用一个判断语句完成对旋转后**最小非平衡子树**bf值的计算。最大限度的提升了效率。

有时间再实现avl树的删除操作。